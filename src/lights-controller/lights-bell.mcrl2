% Railway Crossing Model
% Group 8

%STAY_STATE: state of the system remains the same (loop back), these might be optimized in the future
%ERROR_STATE: state of the system is non trivial and should not occur during regular operation

%NOTE: So in an error state, the system might still remain in the same state (do a loop back), but it might also try to correct the system.

sort State = struct on | off;
	 Train = struct train | no_train;

map opp: State -> State;

var stateL,stateBe,stateBa : State;
	T: Train;

eqn opp(on) = off;
	opp(off) = on;

act set_lights,get_lights,comm_lights: State;
	set_bells,get_bells,comm_bells: State;
	set_barriers,get_barriers,comm_barriers: State;
	done;

proc LIGHTS(stateL: State,stateBe: State,T : Train) =
 ((stateL == on ) && (stateBe == on ) && (T ==    train)) -> set_lights(   (stateL)) . LIGHTS(stateL=   (stateL))	%STAY_STATE
+((stateL == on ) && (stateBe == on ) && (T == no_train)) -> set_lights(   (stateL)) . LIGHTS(stateL=   (stateL))	%STAY_STATE
+((stateL == on ) && (stateBe == off) && (T ==    train)) -> set_lights(   (stateL)) . LIGHTS(stateL=   (stateL))	%STAY_STATE
+((stateL == on ) && (stateBe == off) && (T == no_train)) -> set_lights(opp(stateL)) . LIGHTS(stateL=opp(stateL))
+((stateL == off) && (stateBe == on ) && (T ==    train)) -> set_lights(opp(stateL)) . LIGHTS(stateL=opp(stateL))	%ERROR_STATE
+((stateL == off) && (stateBe == on ) && (T == no_train)) -> set_lights(   (stateL)) . LIGHTS(stateL=   (stateL))	%ERROR_STATE
+((stateL == off) && (stateBe == off) && (T ==    train)) -> set_lights(opp(stateL)) . LIGHTS(stateL=opp(stateL))
+((stateL == off) && (stateBe == off) && (T == no_train)) -> set_lights(   (stateL)) . LIGHTS(stateL=   (stateL))	%STAY_STATE
+ sum s: State . get_bells(s) . LIGHTS(stateBe=s);

proc BELLS(stateBe: State,stateL: State,stateBa: State, T : Train) =
 ((stateBe == on ) && (stateL == on ) && (stateBa == on ) && (T ==    train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%STAY_STATE
+((stateBe == on ) && (stateL == on ) && (stateBa == on ) && (T == no_train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%STAY_STATE
+((stateBe == on ) && (stateL == on ) && (stateBa == off) && (T ==    train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%STAY_STATE
+((stateBe == on ) && (stateL == on ) && (stateBa == off) && (T == no_train)) -> set_bells(opp(stateBe)) . BELLS(stateBe=opp(stateBe))
+((stateBe == on ) && (stateL == off) && (stateBa == on ) && (T ==    train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%ERROR_STATE
+((stateBe == on ) && (stateL == off) && (stateBa == on ) && (T == no_train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%ERROR_STATE
+((stateBe == on ) && (stateL == off) && (stateBa == off) && (T ==    train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%ERROR_STATE
+((stateBe == on ) && (stateL == off) && (stateBa == off) && (T == no_train)) -> set_bells(opp(stateBe)) . BELLS(stateBe=opp(stateBe))	%ERROR_STATE

+((stateBe == off) && (stateL == on ) && (stateBa == on ) && (T ==    train)) -> set_bells(opp(stateBe)) . BELLS(stateBe=opp(stateBe))	%ERROR_STATE
+((stateBe == off) && (stateL == on ) && (stateBa == on ) && (T == no_train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%ERROR_STATE
+((stateBe == off) && (stateL == on ) && (stateBa == off) && (T ==    train)) -> set_bells(opp(stateBe)) . BELLS(stateBe=opp(stateBe))
+((stateBe == off) && (stateL == on ) && (stateBa == off) && (T == no_train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%STAY_STATE
+((stateBe == off) && (stateL == off) && (stateBa == on ) && (T ==    train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%ERROR_STATE
+((stateBe == off) && (stateL == off) && (stateBa == on ) && (T == no_train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%ERROR_STATE
+((stateBe == off) && (stateL == off) && (stateBa == off) && (T ==    train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%STAY_STATE
+((stateBe == off) && (stateL == off) && (stateBa == off) && (T == no_train)) -> set_bells(   (stateBe)) . BELLS(stateBe=   (stateBe))	%STAY_STATE
+ sum s: State . get_lights(s) . BELLS(stateL=s)
+ sum s: State . get_barriers(s) . BELLS(stateBa=s);

proc BARRIERS(stateBa: State,stateBe: State,T : Train) =
 ((stateBa == on ) && (stateBe == on ) && (T ==    train)) -> set_barriers(   (stateBa)) . BARRIERS(stateBa=   (stateBa))	%STAY_STATE
+((stateBa == on ) && (stateBe == on ) && (T == no_train)) -> set_barriers(opp(stateBa)) . BARRIERS(stateBa=opp(stateBa))
+((stateBa == on ) && (stateBe == off) && (T ==    train)) -> set_barriers(   (stateBa)) . BARRIERS(stateBa=   (stateBa))	%ERROR_STATE
+((stateBa == on ) && (stateBe == off) && (T == no_train)) -> set_barriers(opp(stateBa)) . BARRIERS(stateBa=opp(stateBa))	%ERROR_STATE
+((stateBa == off) && (stateBe == on ) && (T ==    train)) -> set_barriers(opp(stateBa)) . BARRIERS(stateBa=opp(stateBa))
+((stateBa == off) && (stateBe == on ) && (T == no_train)) -> set_barriers(   (stateBa)) . BARRIERS(stateBa=   (stateBa))	%STAY_STATE
+((stateBa == off) && (stateBe == off) && (T ==    train)) -> set_barriers(   (stateBa)) . BARRIERS(stateBa=   (stateBa))	%STAY_STATE
+((stateBa == off) && (stateBe == off) && (T == no_train)) -> set_barriers(   (stateBa)) . BARRIERS(stateBa=   (stateBa))	%STAY_STATE
+ sum s: State . get_bells(s) . BARRIERS(stateBe=s);

init allow({set_bells,comm_lights,comm_bells,comm_barriers},
		comm(
			{set_lights|get_lights -> comm_lights,
			set_bells|get_bells -> comm_bells,
			set_barriers|get_barriers -> comm_barriers},
			LIGHTS(on,on,no_train) || BELLS(on,on,on,no_train) || BARRIERS(on,on,no_train) 
		)
	);